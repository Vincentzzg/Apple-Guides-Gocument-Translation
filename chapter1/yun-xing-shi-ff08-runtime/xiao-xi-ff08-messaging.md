# 消息（Messaging）

这个章节描述消息表达式如何被转换成objc\_msgSend函数调用，以及如何通过名称引用方法。然后解释如何利用objc\_msgSend，以及如果需要你如何绕过动态绑定。

## objc\_msgSend函数（The objc\_msgSend Function）

在Objective-C，消息直到运行时才被绑定到方法实现。编译器转换一个消息表达式，

```
[receiver message]
```

到一个消息函数的调用，objc\_msgSend。这个函数将接受者和消息中提到的方法实现的名称（即方法选择器）作为其两个主要参数：

```
objc_msgSend(receiver, selector)
```

消息中传递的任何参数也将传递给objc\_msgSend：

```
objc_msgSend(receiver, selector, arg1, arg2, ...)
```

消息传递功能完成动态绑定所需的一切：

* 它首先找到选择器引用的过程（方法实现）。由于同样的方法可以通过不同的类产生不同的实现，它发现的精确过程依赖于接受者的类。
* 然后它调用过程，将接收的对象（指向其数据的指针）以及为该方法指定的任何参数传递给过程。
* 最后，它传递过程的返回值作为它自己的返回值。

> 注意：编译器生成对消息传递函数的调用。你不应该在你写的代码中直接调用它。

消息传递的关键在于编译器为每个类和对象构建的结构。每个类结构包含着两个基本要素：

* 一个指向超类的指针。
* 一个类调度表。该表具有将方法选择器和它们识别的方法的类特定地址相关联的条目。_setOrigin::_方法的选择器跟_setOrigin::_的地址（实现的过程）相关联，_display_方法的选择器跟_display_的地址相关联，以此类推。

当一个新对象创建，它的内存被分配，它的实例变量被初始化。对象的变量中的第一个是一个指向它的类结构的指针。这个名为isa的指针为对象提供对其类的访问权限，并通过该类访问所有从它继承的类。

> 注意：尽管不是该语言的一部分，对象需要使用isa指针才能与Objective-C运行时系统一起工作。一个对象需要与结构objc\_object（在objc/objc.h中定义）在结构定义的任何字段中“等价”。但是，你很少需要创建自己的根对象，并且从NSObject或NSProxy继承的对象自动具有isa变量。

这些类和对象结构的元素如下图所示。

当消息发送到一个对象时，消息传递函数跟随对象的isa指针，指向查找调度表中的方法选择器的类结构。如果在那里没能发现选择器，objc\_msgSend跟随指针到超类，并尝试在该类的调度表中发现选择器。连续失败导致objc\_msgSend爬上类层次结构，直到它到达NSObject类。一旦他定位到选择器，该函数将调用在表中输入的方法并将接收对象的数据结构传递给它。

这就是运行时选择方法实现的方式--或者，在面向对象的术语中，方法是动态绑定到消息的。

为了加速消息传递过程，运行时系统缓存选择器和方法的地址。每个类都有独立的缓存，并且它可以包含继承的方法的选择器以及类中定义的方法。查找调度表之前，消息传递首先例行检查接收对象的类的缓存（理论上曾经使用过的方法可能会再次使用）。如果方法选择器在缓存中，消息传递只比函数调用慢一点。一旦一个程序已经运行足够长的时间来“预热”它的缓存，几乎它发送的所有消息都能发现缓存的方法。程序运行时，缓存动态增长以适应新的消息。

## 使用隐藏的参数（Using Hidden Arguments）

当objc\_msgSend发现实现一个方法的过程，它调用过程并把消息中的所有参数传递给它。它也传递给过程两个隐藏的参数：

* 接收对象
* 方法的选择器

这些参数为每个方法提供了关于调用它的消息表达式的两半的确切信息。它们被称作“隐藏的”，因为它们没有在方法定义的源码中声明。它们在代码编译时被插入到实现中。

尽管这些方法没有被明确的声明，源码依然可以引用他们（就像它可以引用接收对象的实例变量一样）。方法引用接收对象称为self，他自己的选择器作为cmd。下面的例子中，\_cmd引用strange方法的选择器，self引用接收strange方法的对象。

```
- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();
 
    if ( target == self || method == _cmd )
        return nil;
    return [target performSelector:method];
}
```

两个参数中self更有用。实际上，接收对象的实例变量可用以方法定义。

## 获取方法的地址（Getting a Method Address）



