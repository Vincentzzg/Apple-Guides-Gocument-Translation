# 并发性和应用程序设计（Concurrency and Application Design）

在计算的早期，单位时间计算机可以执行的最大工作量取决于CPU的时钟速度。但是随着技术进步以及处理器的设计变得更紧凑，热量和其他的物理限制开始限制处理器的最大时钟速度。所以，芯片制造商寻找其他方式来提升他们的芯片的总的性能。他们找到的解决方案是增加每个芯片上的处理器核心个数。通过提升核心个数，一个单独的芯片每秒可以执行更多的指令，而不用提升CPU速度或改变芯片的尺寸或热特性。唯一的问题是如何利用额外的核心。

为了利用多核，计算机需要软件可以同时地做多件事。对于像OS X或iOS这样的现代多任务处理操作系统，在任何给定的时间都可以有上百或者更多的程序运行，所以在不同的核心间调度每个程序是可能的。然而，这些程序中的大部分都是系统守护进程或后台应用程序，这些应用程序消耗很少的真实处理时间。相反，真正需要的是个别应用更有效的利用额外的核心的方式。

应用程序使用多个内核的传统方式是创建多个线程。然而，随着核心数量的增加，线程解决方案会产生一些问题。最大的问题是线程代码不能很好地扩展到任意数量的内核。你不能创建核心一样多的线程，并期望程序运行良好。你需要知道的是可以有效利用的核心数量，这对于应用程序自己计算是一个挑战。尽管你设法正确获得了数量，编程这么多线程，使它们高效运行以及避免互相干扰，依然是一个挑战。

所以，总结问题，应用程序需要一种方式以利用可变数量的计算机核心。单个应用程序执行的工作数量也需要能够动态地扩展以适应不断变化的系统条件。而且解决方案必须足够简单以免增加利用这些核心所需的工作数量。好消息是苹果的操作系统提供了所有这些问题的解决方案，这个章节将介绍构成这些解决方案的技术以及为了利用它们你可以对你的代码进行的设计调整。

## 从线程迁移（The Move Away from Threads）

尽管线程已经存在很多年且一直有它们的使用，但是它们没有解决以一种可扩展的方式执行多任务的一般性问题。使用线程，创建可扩展的解决方案的负担正好落在了你（开发者）的肩上。你必须决定创建多少线程并且需要根据系统条件的改变动态地调整数量。另外一个问题是你的应用程序承担与创建和维护它使用的任何线程相关的大部分成本。

代替对线程的依赖，OS X和iOS采用一个异步设计途径来解决并行问题。异步函数出现在操作系统里已经很多年了并且经常被用作启动可能消耗长时间的任务，比如从磁盘读取数据。被调用时，异步函数在后台做一些工作来开始一个任务运行但是在任务可能真正完成前返回。通常，这个工作包括请求一个后台线程，在该线程上开始期望的任务，然后当任务完成时发送一个通知（一般通过一个回调函数）给调用者。过去，如果你想做事的异步函数不存在，你必须写你自己的异步函数并创建自己的线程。但是现在，OS X和iOS提供技术允许你异步执行任何任务，而不必自己管理线程。

异步启动任务的一种技术是GCD\(Grand Central Dispatch\)。这个技术负责你通常在你的应用程序中会写的线程管理代码并且移动这些代码到系统级别。所有你必须做的是定义你想执行的任务然后添加它们到合适的调度队列。GCD负责创建需要的线程并且调度你的任务在这些线程上运行。由于线程管理现在是系统的一部分，GCD提供对于任务管理和执行的一种全面的方法，提供比传统线程更好的效率。

操作队列（Operation queue）是非常像调度队列的Objective-C对象。你定义期望执行的任务然后添加它们到一个操作队列，该操作队列处理这些任务的调度和执行。像GCD一样，操作队列为你处理所有的线程管理，确保任务在系统上执行的尽可能快且尽可能高效。

以下部分提供关于调度队列、操作队列以及一些其他你可以在你的应用程序中使用的异步相关的技术。

### 调度队列（Dispatch Queues）

### 调度来源（Dispatch Sources）

### 操作队列（Operation Queues）

## 异步设计技术（Asynchronous Design Techniques）

### 定义应用程序的预期行为（Define Your Application’s Expected Behavior）

### 分解可执行的工作单元（Factor Out Executable Units of Work）

### 确定你需要的队列（Identify the Queues You Need）

### 提高效率的指示（Tips for Improving Efficiency）

## 性能意义（Performance Implications）

## 并发和其他技术（Concurrency and Other Technologies）

### OpenCL（_Open Computing Language_）和并发（OpenCL and Concurrency）

### 什么时候使用线程（When to Use Threads）



