# 并发性和应用程序设计（Concurrency and Application Design）

在计算的早期，单位时间计算机可以执行的最大工作量取决于CPU的时钟速度。但是随着技术进步以及处理器的设计变得更紧凑，热量和其他的物理限制开始限制处理器的最大时钟速度。所以，芯片制造商寻找其他方式来提升他们的芯片的总的性能。他们找到的解决方案是增加每个芯片上的处理器核心个数。通过提升核心个数，一个单独的芯片每秒可以执行更多的指令，而不用提升CPU速度或改变芯片的尺寸或热特性。唯一的问题是如何利用额外的核心。

为了利用多核，计算机需要软件可以同时地做多件事。对于像OS X或iOS这样的现代多任务处理操作系统，在任何给定的时间都可以有上百或者更多的程序运行，所以在不同的核心间调度每个程序是可能的。然而，这些程序中的大部分都是系统守护进程或后台应用程序，这些应用程序消耗很少的真实处理时间。相反，真正需要的是个别应用更有效的利用额外的核心的方式。

应用程序使用多个内核的传统方式是创建多个线程。然而，随着核心数量的增加，线程解决方案会产生一些问题。最大的问题是线程代码不能很好地扩展到任意数量的内核。你不能创建核心一样多的线程，并期望程序运行良好。你需要知道的是可以有效利用的核心数量，这对于应用程序自己计算是一个挑战。尽管你设法正确获得了数量，编程这么多线程，使它们高效运行以及避免互相干扰，依然是一个挑战。

所以，总结问题，应用程序需要一种方式以利用可变数量的计算机核心。单个应用程序执行的工作数量也需要能够动态地扩展以适应不断变化的系统条件。而且解决方案必须足够简单以免增加利用这些核心所需的工作数量。好消息是苹果的操作系统提供了所有这些问题的解决方案，这个章节将介绍构成这些解决方案的技术以及为了利用它们你可以对你的代码进行的设计调整。

## 从线程迁移（The Move Away from Threads）

尽管线程已经存在很多年且一直有它们的使用，但是它们没有解决以一种可扩展的方式执行多任务的一般性问题。使用线程，创建可扩展的解决方案的负担正好落在了你（开发者）的肩上。你必须决定创建多少线程并且需要根据系统条件的改变动态地调整数量。另外一个问题是你的应用程序承担与创建和维护它使用的任何线程相关的大部分成本。

代替对线程的依赖，OS X和iOS采用一个异步设计途径来解决并行问题。异步函数出现在操作系统里已经很多年了并且经常被用作启动可能消耗长时间的任务，比如从磁盘读取数据。被调用时，异步函数在后台做一些工作来开始一个任务运行但是在任务可能真正完成前返回。通常，这个工作包括请求一个后台线程，在该线程上开始期望的任务，然后当任务完成时发送一个通知（一般通过一个回调函数）给调用者。过去，如果你想做事的异步函数不存在，你必须写你自己的异步函数并创建自己的线程。但是现在，OS X和iOS提供技术允许你异步执行任何任务，而不必自己管理线程。

异步启动任务的一种技术是GCD\(Grand Central Dispatch\)。这个技术负责你通常在你的应用程序中会写的线程管理代码并且移动这些代码到系统级别。所有你必须做的是定义你想执行的任务然后添加它们到合适的调度队列。GCD负责创建需要的线程并且调度你的任务在这些线程上运行。由于线程管理现在是系统的一部分，GCD提供对于任务管理和执行的一种全面的方法，提供比传统线程更好的效率。

操作队列（Operation queue）是非常像调度队列的Objective-C对象。你定义期望执行的任务然后添加它们到一个操作队列，该操作队列处理这些任务的调度和执行。像GCD一样，操作队列为你处理所有的线程管理，确保任务在系统上执行的尽可能快和高效。

以下部分提供关于调度队列、操作队列以及一些其他你可以在你的应用程序中使用相关的异步技术。

### 调度队列（Dispatch Queues）

调度队列是执行自定义任务的基于C的机制。调度队列串行或并行执行任务，但总是先进先出的顺序。（换个说法，调度队列总是以任务加入队列的顺序出列并开始任务。）串行调度队列一次只运行一个任务，知道等到任务完成才出列并开始一个新任务。相反，并行调度队列开始尽可能多的任务，而不等待已经开始的任务结束。

调度队列有其他好处：

* 它们提供直接且简单的编程接口。
* 它们提供自动且全面的线程池管理。
* 它们提供调整部件的速度。（They provide the speed of tuned assembly.）
* 它们内存更高效（因为线程栈不占用应用程序内存）。
* 它们不会再负载下陷入内核。
* 异步调度任务到调度队列不能使队列死锁。
* 它们在竞争中优雅地缩放。（They scale gracefully under contention.）
* 串行调度队列为锁和其他同步原语（primitives）提供更高效的替代方案。

你提交到调度队列的任务必须封装在函数或块对象中。块对象是OS X10.6和iOS4.0发布的C语言特性，概念上跟函数指针接近，但是有一些额外的益处。通常在其他函数或方法中定义块以至于它们可以从该函数或方法中获取其他变量，而不是在块自己的词法范围内定义它们。块也可以被移出它们的原始范围并且拷贝到堆中，这就是当你提交它们到调度队列时发生的。所有这些语义使用相对少的代码实现非常动态的任务变得可能。

调度队列是GCD技术和C运行时的一部分。更多关于在应用程序中使用调度队列的信息，参[Dispatch Queues](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1)。更多关于块和它们的益处的信息，参阅[_Blocks Programming Topics_](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502)。

### 调度源（Dispatch Sources）

调度源是异步处理特定类型的系统事件的一个基于C的机制。调度源封装关于特定类型系统事件的信息并提交一个特定的块对象或函数到事件出现的调度队列。你可以使用调度源观察下列类型的系统事件：

* 定时器
* 信号处理器
* 描述相关事件
* 处理相关事件
* Mach port events
* 你触发的自定义事件

调度源是GCD技术的一部分。关于在应用程序中使用调度源接收事件的更多信心，参阅[Dispatch Sources](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1)。

### 操作队列（Operation Queues）

操作队列是并发调度队列的Cocoa等价物，通过NSOperationQueue类实现。鉴于调度队列总是以先进先出的顺序执行任务，操作队列在决定任务的执行顺序时把其他的因素考虑在内。这些因素中最主要的是任务是否依赖于其他任务的完成。当定义你的任务时设置依赖，你可以使用它们为你的任务创建复杂的执行顺序图。

提交给操作队列的任务必须是NSOperation类的实例。操作对象是一个封装了你想执行的工作和任何执行它需要的数据的Objective-C对象。由于NSOperation类本质上是抽象基类，你通常定义自定义子类来执行你的任务。然而，Foundation框架确实包含一些可以创建并使用的具体子类来执行任务。

## 异步设计技术（Asynchronous Design Techniques）

### 定义应用程序的预期行为（Define Your Application’s Expected Behavior）

### 分解可执行的工作单元（Factor Out Executable Units of Work）

### 确定你需要的队列（Identify the Queues You Need）

### 提高效率的指示（Tips for Improving Efficiency）

## 性能意义（Performance Implications）

## 并发和其他技术（Concurrency and Other Technologies）

### OpenCL（_Open Computing Language_）和并发（OpenCL and Concurrency）

### 什么时候使用线程（When to Use Threads）



